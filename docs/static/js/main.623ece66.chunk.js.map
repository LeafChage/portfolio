{"version":3,"sources":["setting/Route.ts","components/Header.tsx","components/contents/profile/Profile.tsx","setting/Endpoint.ts","util/APIRequest.ts","components/contents/blog/contents/SyntaxHighlightComponent.tsx","components/contents/blog/contents/BlogContentComponent.tsx","components/contents/blog/contents/BlogListComponent.tsx","components/contents/blog/BlogRootComponent.tsx","components/contents/error/404.tsx","components/Main.tsx","components/Footer.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Route","Home","Profile","BlogRoute","BlogList","Blog","BlogContent","MakeBlogContent","id","replace","toString","Header","to","Emoji","props","role","aria-label","label","value","src","alt","className","href","Endpoint","BlogInformation","APIRequest","fetchBlogs","a","axios","get","then","res","data","blogs","catch","console","log","fetchContent","contentURL","SyntaxHighlightComponent","style","hybrid","children","R2R","require","BlogContentComponent","state","fetchStateCancel","content","this","blog","url","setState","Unified","use","RParse","remarkReactComponents","code","SyntaxHighlighter","processSync","contents","fetchContentCancel","renderContent","React","Component","BlogListComponent","map","key","date","title","BlogRootComponent","exact","path","render","match","parseInt","params","Error404","Main","component","ReactRouter","Footer","App","Boolean","window","location","hostname","ReactDOM","document","getElementById","navigator","serviceWorker","ready","registration","unregister","error","message"],"mappings":"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","file":"static/js/main.623ece66.chunk.js","sourcesContent":["export class Route {\n    public static readonly Home = \"/\";\n    public static readonly Profile = \"/profile\";\n    public static readonly Blog = \"/blog\";\n}\n\nexport class BlogRoute {\n    public static readonly BlogList = Route.Blog + \"/\";\n    public static readonly BlogContent = Route.Blog + \"/:id\";\n    public static MakeBlogContent = (id: number) => BlogRoute.BlogContent.replace(\":id\", id.toString());\n}\n\nexport default Route;","import React from 'react';\nimport './Header.scss';\nimport { Link } from 'react-router-dom';\nimport { Route } from '../setting/Route';\n\nconst Header: React.SFC = () => (\n  <header>\n    <ul>\n      <li>\n        <Link to={Route.Profile}>profile</Link>\n      </li>\n      <li>\n        <Link to={Route.Blog}>blog</Link>\n      </li>\n    </ul>\n  </header>\n);\n\nexport default Header;\n","import React from 'react';\nimport './Profile.scss';\n\n\ninterface EmojiProps {\n  label: string\n  value: string\n}\n\nconst Emoji: React.SFC<EmojiProps> = (props: EmojiProps) => (\n  <span role=\"img\" aria-label={props.label}>\n    {props.value}\n  </span>\n);\n\nconst Profile: React.SFC = () => (\n  <main id=\"profile\">\n    <div id=\"top\">\n      <img\n        src=\"https://avatars2.githubusercontent.com/u/18657444?s=460&u=3c5563778bc80f0637307e0ddcaa3f14d285950a&v=4\"\n        alt=\"chage's icon\"\n      ></img>\n      <h1>LeafChage</h1>\n      <p>This is a profile, isn't this? What do you think?</p>\n    </div>\n\n    <div id=\"skillset\">\n      <h2>SkillSets</h2>\n      <ul>\n        <li>\n          <p>\n            <Emoji label=\"mouse\" value=\"🐭\" />\n          </p>\n          <p>Golang</p>\n        </li>\n        <li>\n          <p>\n            <Emoji label=\"elephant\" value=\"🐘\" />\n          </p>\n          <p> PHP </p>\n        </li>\n        <li>\n          <p>\n            <span className=\"blue-text\">TS</span>\n          </p>\n          <p>TypeScript</p>\n        </li>\n        <li>\n          <p>\n            <Emoji label=\"game\" value=\"🎮\" />\n          </p>\n          <p>Unity with C#</p>\n        </li>\n        <li>\n          <p>\n            <Emoji label=\"bird\" value=\"🕊\" />\n          </p>\n          <p>Swift</p>\n        </li>\n      </ul>\n    </div>\n\n    <div id=\"products\">\n      <h2>Little Funny Products</h2>\n      <ul>\n        <li>\n          This is so interesting game in the world.\n          <a href=\"https://leafchage.github.io/FaceRolling/\">FaceRolling</a>\n        </li>\n      </ul>\n    </div>\n  </main>\n);\n\nexport default Profile;\n","class Endpoint {\n    public static readonly BlogInformation = \"/blog/blog.json\";\n}\n\nexport default Endpoint;","import axios from \"axios\";\nimport Endpoint from \"setting/Endpoint\";\nimport Blog from \"../entity/Blog\";\n\nclass APIRequest {\n    public static fetchBlogs = async (): Promise<Blog[]> => {\n        return axios.get(Endpoint.BlogInformation)\n            .then(res => {\n                const blogs = res.data.blogs as Blog[];\n                return blogs;\n            }).catch(res => {\n                console.log(res);\n                return [];\n            })\n    }\n\n    public static fetchContent = async (contentURL: string): Promise<string> => {\n        return axios.get(contentURL)\n            .then(res => {\n                return res.data;\n            }).catch(res => {\n                console.log(res);\n                return \"\";\n            })\n    }\n}\n\nexport default APIRequest;\n\n","import React from 'react';\nimport SyntaxHighlighter from 'react-syntax-highlighter';\nimport hybrid from 'react-syntax-highlighter/dist/esm/styles/hljs/hybrid';\n\nconst SyntaxHighlightComponent: React.SFC = props => {\n  return <SyntaxHighlighter style={hybrid}>{props.children}</SyntaxHighlighter>;\n};\n\nexport default SyntaxHighlightComponent;\n","import React from 'react';\nimport Blog from '../../../../entity/Blog';\nimport APIRequest from '../../../../util/APIRequest';\nimport SyntaxHighlighter from './SyntaxHighlightComponent';\nimport RParse from 'remark-parse';\nimport Unified from 'unified';\nconst R2R = require('remark-react');\n\ninterface BlogContentState {\n  content: string;\n}\n\ninterface BlogContentProps {\n  blog?: Blog;\n}\n\nclass BlogContentComponent extends React.Component<\n  BlogContentProps,\n  BlogContentState\n> {\n  constructor(props: BlogContentProps, state: BlogContentState) {\n    super(props, state);\n    this.state = {\n      content: '',\n    };\n  }\n\n  private fetchStateCancel: boolean = false;\n  private async fetchContent() {\n    if (this.props.blog) {\n      const content = await APIRequest.fetchContent(this.props.blog.url);\n      if (!this.fetchStateCancel) {\n        this.setState({ content: content });\n      }\n    }\n  }\n\n  private fetchContentCancel() {\n    this.fetchStateCancel = true;\n  }\n\n  renderContent() {\n    return (\n      <div id=\"preview\">\n        {\n          Unified()\n            .use(RParse)\n            .use(R2R, { remarkReactComponents: { code: SyntaxHighlighter } })\n            .processSync(this.state.content).contents\n        }\n      </div>\n    );\n  }\n\n  // React Lifecycle\n  componentDidUpdate() {\n    this.fetchContent();\n  }\n\n  componentDidMount() {\n    this.fetchContent();\n  }\n\n  componentWillUnmount() {\n    this.fetchContentCancel();\n  }\n\n  render() {\n    return this.renderContent();\n  }\n}\n\nexport default BlogContentComponent;\n","import React from 'react';\nimport Blog from '../../../../entity/Blog';\nimport { Link } from 'react-router-dom';\nimport { BlogRoute } from 'setting/Route';\n\ninterface BlogListProps {\n  blogs: Blog[];\n}\n\nconst BlogListComponent: React.SFC<BlogListProps> = (props) => (\n  <ul>\n    {props.blogs.map((blog) => (\n      <li key={blog.date}>\n        <Link to={BlogRoute.MakeBlogContent(blog.id)}>\n          {blog.title} {blog.date}\n        </Link>\n      </li>\n    ))}\n  </ul>\n);\n\nexport default BlogListComponent;\n","import React from 'react';\nimport BlogContentComponent from './contents/BlogContentComponent';\nimport BlogListComponent from './contents/BlogListComponent';\nimport Blog from '../../../entity/Blog';\nimport APIRequest from '../../../util/APIRequest';\nimport * as ReactRouter from 'react-router-dom';\nimport { match } from 'react-router-dom';\nimport './BlogRootComponent.scss';\nimport { BlogRoute } from 'setting/Route';\n\ninterface BlogState {\n  blogs: Blog[];\n}\n\ninterface BlogProps {\n  match: match<{ id: string }>;\n}\n\nclass BlogRootComponent extends React.Component<BlogProps, BlogState> {\n  constructor(props: BlogProps, state: BlogState) {\n    super(props, state);\n    this.state = { blogs: [] };\n  }\n\n  private async fetchBlogs() {\n    const blogs = await APIRequest.fetchBlogs();\n    this.setState({ blogs: blogs });\n  }\n\n  componentDidMount() {\n    this.fetchBlogs();\n  }\n\n  render() {\n    return (\n      <main id=\"blog\">\n        <ReactRouter.Link to={BlogRoute.BlogList}>Blogs</ReactRouter.Link>\n        <ReactRouter.Switch>\n          <ReactRouter.Route\n            exact\n            path={BlogRoute.BlogList}\n            render={() => <BlogListComponent blogs={this.state.blogs} />}\n          />\n          <ReactRouter.Route\n            exact\n            path={BlogRoute.BlogContent}\n            render={({ match }) => {\n              return (\n                <BlogContentComponent\n                  blog={this.state.blogs[parseInt(match.params.id)]}\n                />\n              );\n            }}\n          />\n        </ReactRouter.Switch>\n      </main>\n    );\n  }\n}\n\nexport default BlogRootComponent;\n","import React from 'react';\nconst Error404: React.SFC = () => <h1>this is error</h1>;\n\nexport default Error404;\n","import React from 'react';\nimport * as ReactRouter from 'react-router-dom';\nimport Profile from '../components/contents/profile/Profile';\nimport Blog from './contents/blog/BlogRootComponent';\nimport Error404 from '../components/contents/error/404';\nimport { Route } from 'setting/Route';\n\nclass Main extends ReactRouter.BrowserRouter {\n  render() {\n    return (\n      <ReactRouter.Switch>\n        <ReactRouter.Route path={Route.Profile} component={Profile} />\n        <ReactRouter.Route path={Route.Blog} component={Blog} />\n        <ReactRouter.Route path={Route.Home} component={Profile} />\n        <ReactRouter.Route component={Error404} />\n      </ReactRouter.Switch>\n    );\n  }\n}\n\nexport default Main;\n","import React from 'react';\nimport './Footer.scss';\n\nconst Footer: React.SFC = () => (\n  <footer>\n    <p>Thank you for reading this to the end.</p>\n  </footer>\n);\n\nexport default Footer;\n","import React from 'react';\nimport { BrowserRouter as Router } from 'react-router-dom';\nimport './App.scss';\nimport Header from './components/Header';\nimport Main from './components/Main';\nimport Footer from './components/Footer';\n\nfunction App() {\n  return (\n    <div id=\"App\">\n      <Router>\n        <Header />\n        <Main />\n        <Footer />\n      </Router>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}